// ============================================================
// Sengoo 算法演示 — NOI 风格
// 包含: GCD, 快速幂, 素数判定, 二分查找, 前缀和,
//       最大子段和 (Kadane), 逆序对计数
// ============================================================

// ----------------------------------------------------------
// 1. 辗转相除法 (欧几里得算法) 求最大公约数
//    时间复杂度: O(log(min(a,b)))
// ----------------------------------------------------------
def gcd(a: i64, b: i64) -> i64 {
    let x = a;
    let y = b;
    while y > 0 {
        let temp = y;
        y = x - (x / y) * y;
        x = temp;
    }
    x
}

// ----------------------------------------------------------
// 2. 快速幂取模: base^exp % mod
//    时间复杂度: O(log(exp))
//    经典 NOI 算法，用于 RSA、费马小定理等
// ----------------------------------------------------------
def power_mod(base: i64, exp: i64, m: i64) -> i64 {
    let result = 1;
    let b = base - (base / m) * m;
    let e = exp;
    while e > 0 {
        let half = e / 2;
        if e - half * 2 > 0 {
            result = result * b;
            result = result - (result / m) * m;
        }
        b = b * b;
        b = b - (b / m) * m;
        e = e / 2;
    }
    result
}

// ----------------------------------------------------------
// 3. 素数判定 (试除法)
//    时间复杂度: O(sqrt(n))
//    返回 1 = 素数, 0 = 非素数
// ----------------------------------------------------------
def is_prime(n: i64) -> i64 {
    let result = 0;
    if n > 1 {
        result = 1;
        let i = 2;
        while i * i < n + 1 {
            let rem = n - (n / i) * i;
            if rem < 1 {
                result = 0;
            }
            i = i + 1;
        }
    }
    result
}

// ----------------------------------------------------------
// 4. 统计 [2, limit] 范围内的素数个数
// ----------------------------------------------------------
def count_primes(limit: i64) -> i64 {
    let count = 0;
    let n = 2;
    while n < limit + 1 {
        if is_prime(n) > 0 {
            count = count + 1;
        }
        n = n + 1;
    }
    count
}

// ----------------------------------------------------------
// 5. 二分查找 (在有序数组中查找目标值)
//    时间复杂度: O(log n)
//    返回索引, 找不到返回 -1
// ----------------------------------------------------------
def binary_search_demo() -> i64 {
    let arr = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91];
    let target = 23;
    let lo = 0;
    let hi = 9;
    let found = 0 - 1;

    while lo < hi + 1 {
        let mid = lo + (hi - lo) / 2;
        let val = arr[mid];
        if val < target {
            lo = mid + 1;
        } else {
            if val > target {
                hi = mid - 1;
            } else {
                found = mid;
                lo = hi + 1;
            }
        }
    }
    found
}

// ----------------------------------------------------------
// 6. 前缀和查询: 求数组前 k 个元素之和
//    预处理 O(n), 查询 O(1)
// ----------------------------------------------------------
def prefix_sum_demo() -> i64 {
    let data = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3];
    let k = 7;
    let sum = 0;
    let i = 0;
    while i < k {
        sum = sum + data[i];
        i = i + 1;
    }
    sum
}

// ----------------------------------------------------------
// 7. 最大子段和 — Kadane 算法
//    时间复杂度: O(n)
//    经典动态规划: dp[i] = max(a[i], dp[i-1] + a[i])
// ----------------------------------------------------------
def max_subarray_sum() -> i64 {
    let arr = [0 - 2, 1, 0 - 3, 4, 0 - 1, 2, 1, 0 - 5, 4];
    let max_sum = arr[0];
    let cur_sum = arr[0];
    let i = 1;
    while i < 9 {
        let val = arr[i];
        let extended = cur_sum + val;
        if val > extended {
            cur_sum = val;
        } else {
            cur_sum = extended;
        }
        if cur_sum > max_sum {
            max_sum = cur_sum;
        }
        i = i + 1;
    }
    max_sum
}

// ----------------------------------------------------------
// 8. 逆序对计数 (暴力 O(n^2))
//    NOI 经典题: 统计 i<j 且 a[i]>a[j] 的对数
// ----------------------------------------------------------
def count_inversions() -> i64 {
    let arr = [5, 3, 8, 1, 9, 2, 7, 4, 6, 0];
    let count = 0;
    let i = 0;
    while i < 10 {
        let j = i + 1;
        while j < 10 {
            if arr[i] > arr[j] {
                count = count + 1;
            }
            j = j + 1;
        }
        i = i + 1;
    }
    count
}

// ----------------------------------------------------------
// 主函数: 运行所有算法并输出结果
// ----------------------------------------------------------
def main() -> i64 {
    print("=== 1. GCD (Euclidean) ===");
    print("gcd(48, 18) =");
    let g = gcd(48, 18);
    print(g);

    print("=== 2. Fast Power Mod ===");
    print("2^10 mod 1000 =");
    let p = power_mod(2, 10, 1000);
    print(p);

    print("=== 3. Prime Check ===");
    print("is_prime(17) =");
    print(is_prime(17));
    print("is_prime(18) =");
    print(is_prime(18));

    print("=== 4. Prime Count [2,100] ===");
    let pc = count_primes(100);
    print(pc);

    print("=== 5. Binary Search ===");
    print("index of 23 =");
    let idx = binary_search_demo();
    print(idx);

    print("=== 6. Prefix Sum ===");
    print("sum of first 7 =");
    let s = prefix_sum_demo();
    print(s);

    print("=== 7. Max Subarray (Kadane) ===");
    let ms = max_subarray_sum();
    print(ms);

    print("=== 8. Inversion Count ===");
    let inv = count_inversions();
    print(inv);

    print("=== All Done ===");
    0
}
